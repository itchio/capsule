// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGES_CAPSULE_MESSAGES_H_
#define FLATBUFFERS_GENERATED_MESSAGES_CAPSULE_MESSAGES_H_

#include "flatbuffers/flatbuffers.h"

namespace capsule {
namespace messages {

struct Packet;

struct CaptureStart;

struct CaptureStop;

struct VideoSetup;

struct Shmem;

struct VideoFrameCommitted;

struct VideoFrameProcessed;

enum PixFmt {
  PixFmt_UNKNOWN = 0,
  PixFmt_RGBA = 40069,
  PixFmt_BGRA = 40070,
  PixFmt_RGB10_A2 = 40071,
  PixFmt_YUV444P = 60021,
  PixFmt_MIN = PixFmt_UNKNOWN,
  PixFmt_MAX = PixFmt_YUV444P
};

enum Message {
  Message_NONE = 0,
  Message_CaptureStart = 1,
  Message_CaptureStop = 2,
  Message_VideoSetup = 3,
  Message_VideoFrameCommitted = 4,
  Message_VideoFrameProcessed = 5,
  Message_MIN = Message_NONE,
  Message_MAX = Message_VideoFrameProcessed
};

inline const char **EnumNamesMessage() {
  static const char *names[] = {
    "NONE",
    "CaptureStart",
    "CaptureStop",
    "VideoSetup",
    "VideoFrameCommitted",
    "VideoFrameProcessed",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<CaptureStart> {
  static const Message enum_value = Message_CaptureStart;
};

template<> struct MessageTraits<CaptureStop> {
  static const Message enum_value = Message_CaptureStop;
};

template<> struct MessageTraits<VideoSetup> {
  static const Message enum_value = Message_VideoSetup;
};

template<> struct MessageTraits<VideoFrameCommitted> {
  static const Message enum_value = Message_VideoFrameCommitted;
};

template<> struct MessageTraits<VideoFrameProcessed> {
  static const Message enum_value = Message_VideoFrameProcessed;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Message message_type() const {
    return static_cast<Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

struct PacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Message message_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Packet::VT_MESSAGE, message);
  }
  PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    Message message_type = Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct CaptureStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FPS = 4,
    VT_SIZE_DIVIDER = 6,
    VT_GPU_COLOR_CONV = 8
  };
  uint32_t fps() const {
    return GetField<uint32_t>(VT_FPS, 0);
  }
  uint32_t size_divider() const {
    return GetField<uint32_t>(VT_SIZE_DIVIDER, 0);
  }
  bool gpu_color_conv() const {
    return GetField<uint8_t>(VT_GPU_COLOR_CONV, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FPS) &&
           VerifyField<uint32_t>(verifier, VT_SIZE_DIVIDER) &&
           VerifyField<uint8_t>(verifier, VT_GPU_COLOR_CONV) &&
           verifier.EndTable();
  }
};

struct CaptureStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fps(uint32_t fps) {
    fbb_.AddElement<uint32_t>(CaptureStart::VT_FPS, fps, 0);
  }
  void add_size_divider(uint32_t size_divider) {
    fbb_.AddElement<uint32_t>(CaptureStart::VT_SIZE_DIVIDER, size_divider, 0);
  }
  void add_gpu_color_conv(bool gpu_color_conv) {
    fbb_.AddElement<uint8_t>(CaptureStart::VT_GPU_COLOR_CONV, static_cast<uint8_t>(gpu_color_conv), 0);
  }
  CaptureStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CaptureStartBuilder &operator=(const CaptureStartBuilder &);
  flatbuffers::Offset<CaptureStart> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CaptureStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<CaptureStart> CreateCaptureStart(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t fps = 0,
    uint32_t size_divider = 0,
    bool gpu_color_conv = false) {
  CaptureStartBuilder builder_(_fbb);
  builder_.add_size_divider(size_divider);
  builder_.add_fps(fps);
  builder_.add_gpu_color_conv(gpu_color_conv);
  return builder_.Finish();
}

struct CaptureStop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CaptureStopBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  CaptureStopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CaptureStopBuilder &operator=(const CaptureStopBuilder &);
  flatbuffers::Offset<CaptureStop> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<CaptureStop>(end);
    return o;
  }
};

inline flatbuffers::Offset<CaptureStop> CreateCaptureStop(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CaptureStopBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VideoSetup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_PIX_FMT = 8,
    VT_VFLIP = 10,
    VT_OFFSET = 12,
    VT_LINESIZE = 14,
    VT_SHMEM = 16
  };
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  PixFmt pix_fmt() const {
    return static_cast<PixFmt>(GetField<int32_t>(VT_PIX_FMT, 0));
  }
  bool vflip() const {
    return GetField<uint8_t>(VT_VFLIP, 0) != 0;
  }
  const flatbuffers::Vector<int64_t> *offset() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OFFSET);
  }
  const flatbuffers::Vector<int64_t> *linesize() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_LINESIZE);
  }
  const Shmem *shmem() const {
    return GetPointer<const Shmem *>(VT_SHMEM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_PIX_FMT) &&
           VerifyField<uint8_t>(verifier, VT_VFLIP) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OFFSET) &&
           verifier.Verify(offset()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LINESIZE) &&
           verifier.Verify(linesize()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SHMEM) &&
           verifier.VerifyTable(shmem()) &&
           verifier.EndTable();
  }
};

struct VideoSetupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(VideoSetup::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(VideoSetup::VT_HEIGHT, height, 0);
  }
  void add_pix_fmt(PixFmt pix_fmt) {
    fbb_.AddElement<int32_t>(VideoSetup::VT_PIX_FMT, static_cast<int32_t>(pix_fmt), 0);
  }
  void add_vflip(bool vflip) {
    fbb_.AddElement<uint8_t>(VideoSetup::VT_VFLIP, static_cast<uint8_t>(vflip), 0);
  }
  void add_offset(flatbuffers::Offset<flatbuffers::Vector<int64_t>> offset) {
    fbb_.AddOffset(VideoSetup::VT_OFFSET, offset);
  }
  void add_linesize(flatbuffers::Offset<flatbuffers::Vector<int64_t>> linesize) {
    fbb_.AddOffset(VideoSetup::VT_LINESIZE, linesize);
  }
  void add_shmem(flatbuffers::Offset<Shmem> shmem) {
    fbb_.AddOffset(VideoSetup::VT_SHMEM, shmem);
  }
  VideoSetupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VideoSetupBuilder &operator=(const VideoSetupBuilder &);
  flatbuffers::Offset<VideoSetup> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<VideoSetup>(end);
    return o;
  }
};

inline flatbuffers::Offset<VideoSetup> CreateVideoSetup(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t width = 0,
    uint32_t height = 0,
    PixFmt pix_fmt = PixFmt_UNKNOWN,
    bool vflip = false,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> linesize = 0,
    flatbuffers::Offset<Shmem> shmem = 0) {
  VideoSetupBuilder builder_(_fbb);
  builder_.add_shmem(shmem);
  builder_.add_linesize(linesize);
  builder_.add_offset(offset);
  builder_.add_pix_fmt(pix_fmt);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_vflip(vflip);
  return builder_.Finish();
}

inline flatbuffers::Offset<VideoSetup> CreateVideoSetupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t width = 0,
    uint32_t height = 0,
    PixFmt pix_fmt = PixFmt_UNKNOWN,
    bool vflip = false,
    const std::vector<int64_t> *offset = nullptr,
    const std::vector<int64_t> *linesize = nullptr,
    flatbuffers::Offset<Shmem> shmem = 0) {
  return capsule::messages::CreateVideoSetup(
      _fbb,
      width,
      height,
      pix_fmt,
      vflip,
      offset ? _fbb.CreateVector<int64_t>(*offset) : 0,
      linesize ? _fbb.CreateVector<int64_t>(*linesize) : 0,
      shmem);
}

struct Shmem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_SIZE = 6
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct ShmemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(Shmem::VT_PATH, path);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(Shmem::VT_SIZE, size, 0);
  }
  ShmemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShmemBuilder &operator=(const ShmemBuilder &);
  flatbuffers::Offset<Shmem> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Shmem>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shmem> CreateShmem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    uint64_t size = 0) {
  ShmemBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shmem> CreateShmemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    uint64_t size = 0) {
  return capsule::messages::CreateShmem(
      _fbb,
      path ? _fbb.CreateString(path) : 0,
      size);
}

struct VideoFrameCommitted FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_INDEX = 6
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           verifier.EndTable();
  }
};

struct VideoFrameCommittedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(VideoFrameCommitted::VT_TIMESTAMP, timestamp, 0);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(VideoFrameCommitted::VT_INDEX, index, 0);
  }
  VideoFrameCommittedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VideoFrameCommittedBuilder &operator=(const VideoFrameCommittedBuilder &);
  flatbuffers::Offset<VideoFrameCommitted> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<VideoFrameCommitted>(end);
    return o;
  }
};

inline flatbuffers::Offset<VideoFrameCommitted> CreateVideoFrameCommitted(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    uint32_t index = 0) {
  VideoFrameCommittedBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_index(index);
  return builder_.Finish();
}

struct VideoFrameProcessed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDEX = 4
  };
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           verifier.EndTable();
  }
};

struct VideoFrameProcessedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(VideoFrameProcessed::VT_INDEX, index, 0);
  }
  VideoFrameProcessedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VideoFrameProcessedBuilder &operator=(const VideoFrameProcessedBuilder &);
  flatbuffers::Offset<VideoFrameProcessed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<VideoFrameProcessed>(end);
    return o;
  }
};

inline flatbuffers::Offset<VideoFrameProcessed> CreateVideoFrameProcessed(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index = 0) {
  VideoFrameProcessedBuilder builder_(_fbb);
  builder_.add_index(index);
  return builder_.Finish();
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_CaptureStart: {
      auto ptr = reinterpret_cast<const CaptureStart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CaptureStop: {
      auto ptr = reinterpret_cast<const CaptureStop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_VideoSetup: {
      auto ptr = reinterpret_cast<const VideoSetup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_VideoFrameCommitted: {
      auto ptr = reinterpret_cast<const VideoFrameCommitted *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_VideoFrameProcessed: {
      auto ptr = reinterpret_cast<const VideoFrameProcessed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const capsule::messages::Packet *GetPacket(const void *buf) {
  return flatbuffers::GetRoot<capsule::messages::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<capsule::messages::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<capsule::messages::Packet> root) {
  fbb.Finish(root);
}

}  // namespace messages
}  // namespace capsule

#endif  // FLATBUFFERS_GENERATED_MESSAGES_CAPSULE_MESSAGES_H_
